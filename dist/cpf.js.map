{"version":3,"sources":["webpack://CPF/webpack/universalModuleDefinition","webpack://CPF/webpack/bootstrap","webpack://CPF/./src/is-false-positive/index.js","webpack://CPF/./src/get-verifier/index.js","webpack://CPF/./src/constants/index.js","webpack://CPF/./src/assert/index.js","webpack://CPF/./src/index.js"],"names":["isFalsePositive","data","every","value","getVerifier","verifier","length","mappings","unshift","index","accumulator","sum","reminder","CPF_REGEX","INVALID_CODE","LENGTH_CODE","VALID_CODE","assert","condition","message","code","errorMessage","error","Error","isCpfCheck","strip","validate","format","generate","raw","Object","prototype","toString","call","replace","trim","rawString","split","parseInt","string","numbers","Number","isNaN","userVerifiers","slice","valid","formatted","Array","fill","Math","floor","random","prefix","firstVerifier","secondVerifier","concat","finalString","join","defineProperties"],"mappings":"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","file":"cpf.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CPF\"] = factory();\n\telse\n\t\troot[\"CPF\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/**\n * Because of how CPF's validity is calculated, number like 11111111111 are valid.\n * To prevent users from abusing this quirk, we check if CPF string follows this\n * pattern and we invalidade if so.\n * @private\n * @param {Array<number>} data Array containing user provided CPF.\n * @returns {boolean} Wether of not the CPF is a false positive.\n */\nexport default function isFalsePositive(data) {\n    return data.every(value => value === data[0]);\n}\n","/**\n * Do some math to check CPF verifier digits.\n * @private\n * @param {Array<number>} data CPF digits, with 9 or 10 numbers.\n * @param {number} verifier Wether to check the first or second verifiers.\n * @returns {number} The verifier digit.\n */\nexport default function getVerifier(data, verifier) {\n    if (data.length < 9 || data.length > 10) {\n        return -1;\n    } else if (data.length === 9 && verifier === 2) {\n        return -1;\n    } else if (data.length === 10 && verifier === 1) {\n        return -1;\n    }\n\n    const mappings = [10, 9, 8, 7, 6, 5, 4, 3, 2];\n\n    if (verifier === 2) {\n        mappings.unshift(11);\n    }\n\n\n    const sum = mappings\n        .map((value, index) => value * data[index])\n        .reduce((accumulator, value) => accumulator + value, 0);\n\n    const reminder = sum % 11;\n\n    if (reminder < 2) {\n        return 0;\n    }\n\n    return 11 - reminder;\n}\n","export const CPF_REGEX = /^(\\d{3})(.|-)?(\\d{3})(.|-)?(\\d{3})(.|-)?(\\d{2})$/;\n\n// Error codes\nexport const INVALID_CODE = 'INVALID';\nexport const LENGTH_CODE = 'LENGTH';\nexport const VALID_CODE = 'VALID';\n","/**\n * Asserts given condition.\n * @private\n * @param {boolean} condition The condition to assert validity of.\n * @param {string|undefined} message The error message to display during development.\n * @param {string} code The error code.\n */\nexport default function assert(condition, message, code) {\n    if (!condition) {\n        const errorMessage = process.env.NODE_ENV === 'production' ?\n            'cpf-check error. Use dev environment for the full error message.' : `cpf-check Error. ${message}`;\n\n        const error = new Error(errorMessage);\n        error.code = code;\n        error.isCpfCheck = true;\n\n        throw error;\n    }\n}\n","import assert from './assert';\nimport { CPF_REGEX, INVALID_CODE, LENGTH_CODE, VALID_CODE } from './constants';\nimport getVerifier from './get-verifier';\nimport isFalsePositive from './is-false-positive';\n\n/**\n * @typedef {Object} ValidationResult\n * @property {boolean} error Wether there were any erros during validation.\n * @property {boolean} valid Wether the provided CPF is valid.\n * @property {string} code Error or success code.\n */\n\n\n/**\n * Strip '-', '.', and anything that is not a digit from the provided input.\n * @public\n * @param      {string}  raw The text input.\n * @return     {string}  Striped down input.\n */\nexport function strip(raw) {\n    assert(\n        Object.prototype.toString.call(raw) === '[object String]',\n        `Expected String but instead got ${typeof raw}`,\n        INVALID_CODE,\n    );\n\n    return raw.replace(/[^\\d]/g, '').trim();\n}\n\n/**\n * Validates CPF's\n * @public\n * @param {any} rawString Value to validate.\n * @returns {ValidationResult} The result of a given validation.\n */\nexport function validate(rawString) {\n    assert(\n        Object.prototype.toString.call(rawString) === '[object String]',\n        `Expected CPF to be a string insead got ${typeof rawString}`,\n    );\n\n\n    try {\n        assert(\n            rawString.length === 11,\n            `Expected CPF to have length of 11 instead got ${rawString.length}`,\n            LENGTH_CODE,\n        );\n\n        const numbers = rawString\n            .replace(CPF_REGEX, '$1$3$5$7')\n            .split('')\n            .map(string => parseInt(string, 10));\n\n        numbers.forEach((value) => {\n            assert(\n                !Number.isNaN(value),\n                `Expected CPF to have only digits but instead got ${value}`,\n                INVALID_CODE,\n            );\n        });\n\n        assert(\n            !isFalsePositive(numbers),\n            'Provided CPF is a false positive.',\n            INVALID_CODE,\n        );\n\n        const userVerifiers = numbers.slice(9);\n\n        assert(\n            userVerifiers[0] === getVerifier(numbers.slice(0, 9), 1),\n            'Provided CPF is invalid.',\n            INVALID_CODE,\n        );\n\n        assert(\n            userVerifiers[1] === getVerifier(numbers.slice(0, 10), 2),\n            'Provided CPF is invalid.',\n            INVALID_CODE,\n        );\n\n        return {\n            error: false,\n            valid: true,\n            code: VALID_CODE,\n        };\n    } catch (error) {\n        if (error.isCpfCheck) {\n            return {\n                error: true,\n                valid: false,\n                code: error.code,\n            };\n        }\n\n        throw error;\n    }\n}\n\n/**\n * Format a given cpf. For example '00000000000' will result in\n * '000.000.000-00'.\n * @public\n * @param      {string}  raw The unformated CPF.\n * @return     {string}  The formated CPF.\n */\nexport function format(raw) {\n    const { valid } = validate(raw);\n\n    assert(\n        valid,\n        'Cannot format invalid CPF strings.',\n        INVALID_CODE,\n    );\n\n    return strip(raw).replace(CPF_REGEX, '$1.$3.$5-$7');\n}\n\n/**\n * Generate new random valid CPF.\n * @public\n * @param {?boolean} formatted Wether or not to format the output;\n * @returns {string} A random valid CPF string.\n */\nexport function generate(formatted = true) {\n    assert(\n        Object.prototype.toString.call(formatted) === '[object Boolean]',\n        `Expected generate argument to be boolean instead got ${typeof formatted}.`,\n        INVALID_CODE,\n    );\n\n    const prefix = Array(9).fill(0)\n        .map(() => Math.floor(Math.random() * (9 - (1 + 1))) + 1);\n\n    const firstVerifier = getVerifier(prefix, 1);\n    const secondVerifier = getVerifier(prefix.concat(firstVerifier), 2);\n\n    const finalString = `${prefix.join('')}${firstVerifier}${secondVerifier}`;\n\n    return formatted ? format(finalString) : finalString;\n}\n\nexport default Object.defineProperties(validate, {\n    strip: { value: strip },\n    format: { value: format },\n    validate: { value: validate },\n    generate: { value: generate },\n});\n"],"sourceRoot":""}