{"version":3,"sources":["index.js"],"names":["module","exports","factory","random","max","min","parse","raw","isString","matches","match","strip","format","transform","replace","regex","Error","_typeof","digits","split","map","digit","parseInt","i","length","checkSum","sum","Array","number","reduce","total","index","remainder","size","Symbol","iterator","obj","constructor","prototype","second","verifiers","slice","first","concat"],"mappings":"2FAEAA,OAAAC,QAAAC,gHA2BA,SAAAC,EAAAC,EAAAC,mFAgBQ,SAAAC,EAAOC,GACV,IAAAC,EAAAD,sGAIJ,IAAAE,EAAAF,EAAAG,MAAA,6DAQQC,EAAT,kKAwBA,SAAAC,EAAAL,uJAMA,OAASM,EAAAA,EAATN,IAAuCO,QAAAC,EAAA,6BAQnC,IAAAP,EAAAD,GACA,MAAA,IAAAS,MAAA,2DAAA,IAAAT,EAAA,YAAAU,EAAAV,KAUJ,IAAA,IANSW,EAAAX,EAAAY,MAAA,IAAAC,IAAA,SAAAC,GACJ,OAAAC,SAAAD,EAAA,MAKLE,EAAAL,EAAAM,OAAA,EAAAD,GAAA,EAAAA,GAAA,+GAMA,OAASE,EASL,SAAMC,EAAMR,GACH,IAAAS,MAAmBC,QAAAA,GACvBC,MAAO,IAAAb,MAACc,4EAAD,IAAAZ,EAAA,YAAAD,EAAAC,2BAKZA,EAAAE,IAAA,SAAAQ,EAAAG,GACA,OAAOC,GAAAC,EAAoBD,KAC9BH,OAAA,SAAAC,EAAAF,kCA1HG,IAAAX,EAAA,mBAAAiB,QAAA,iBAAAA,OAAAC,SAAA,SAAAC,GAAA,cAAAA,GAAA,SAAAA,GAAA,OAAAA,GAAA,mBAAAF,QAAAE,EAAAC,cAAAH,QAAAE,IAAAF,OAAAI,UAAA,gBAAAF,KA4IA,SAAWZ,GACP,IAAAhB,EAAOD,GACV,MAAA,IAAAS,MAAA,sEAAA,IAAAT,EAAA,YAAAU,EAAAV,sBAOD,GAAwBW,KAAlBqB,EAAAA,gBAKL,IAAAC,EAAAtB,EAAAuB,MAAA,EAAA,IAGJC,EAAAjB,EAAAP,EAAAuB,MAAA,EAAA,8GAgBG,WAIA,IAAMF,SAAAA,EAASd,EAAAA,EAAAA,EAASP,GAAAA,6CAQxBP,EAAQA,EAAZO,EAAAuB,MAAA,EAAA,IACI7B,EAASA,EAAbM,EAAAuB,MAAA,EAAA,GAAAE,QAAAD","file":"cpf.ad8108d7.min.js","sourcesContent":["// @flow\n\n/**\n * Determines if given input is a string.\n *\n * @param      {Any}   stg     The input.\n * @return     {boolean}  True if string, False otherwise.\n */\nfunction isString(stg: any): Boolean {\n    // failproffish check\n    return stg.constructor.toString().indexOf('String') !== -1;\n}\n\n/**\n * Returns a random number inside the min-max window.\n *\n * @param      {number}  max     The maximum number.\n * @param      {number}  min     The minimum number.\n * @return     {number}  the random number.\n */\nfunction random(max: Number, min: Number): Number {\n    // Round given range numbers\n    const rMin = Math.ceil(min);\n    const rMax = Math.floor(max);\n\n    // Generates a pseudo-random number with the given range\n    return Math.floor(Math.random() * (rMax - (rMin + 1))) + rMin;\n}\n\n/**\n * Parse a CPF from any text. For example 'this is my cpf 000.000.000-00'\n * will return '000.000.000-00'.\n *\n * @param      {string}  raw     The raw text string.\n * @return     {string}  the found CPF or an empty string.\n */\nfunction parse(raw: String): String {\n    if (!isString(raw)) {\n        throw new Error(`CPF.parse Error\\nExpected String but instead got ${typeof raw}`);\n    }\n    // Extracts all cpf matches from an text string\n    const matches = raw.match(/\\d{3}(.|-)?\\d{3}(.|-)?\\d{3}(.|-)?\\d{2}/);\n\n    // If no matches\n    if (matches === null) {\n        return '';\n    }\n\n    // Return the first match\n    return matches[0];\n}\n\n/**\n * Strip '-', '.', and anything that is not a digit from the provided input.\n *\n * @param      {string}  raw     The text input.\n * @return     {string}  Striped down input.\n */\nfunction strip(raw: String): String {\n    if (!isString(raw)) {\n        throw new Error(`CPF.strip Error\\nExpected String but instead got ${typeof raw}`);\n    }\n\n    return raw.replace(/[^\\d]/g, '').trim();\n}\n\n/**\n * Format a given cpf. For example '00000000000' will result in\n * '000.000.000-00'.\n *\n * @param      {string}  raw     The unformated CPF.\n * @return     {string}  The formated CPF.\n */\nfunction format(raw: String): String {\n    if (!isString(raw)) {\n        throw new Error(`CPF.format Error\\nExpected String but instead got ${typeof raw}`);\n    }\n\n    const regex = /^(\\d{3})(\\d{3})(\\d{3})(\\d{2})$/;\n    return strip(parse(raw)).replace(regex, '$1.$2.$3-$4');\n}\n\n/**\n * Transforms a given CPF string into an Array of the cpfs numbers.\n *\n * @param      {string}  raw     The raw cpf string.\n * @return     {Array}   CPF parsed numbers in an array.\n */\nfunction transform(raw: String): Array {\n    if (!isString(raw)) {\n        throw new Error(`CPF.format Error\\nExpected String but instead got ${typeof raw}`);\n    }\n\n    // Transform input into array and parse the numbers\n    const digits = raw.split('').map(digit => parseInt(digit, 10));\n\n    // if the input did't contain a CPF, parseInt will return NaN, so\n    // we check for this.\n    for (let i = digits.length - 1; i >= 0; i -= 1) {\n        if (Number.isNaN(digits[i])) {\n            throw new Error(`CPF.transform Error\\nExpected digits only string but instead got ${raw}`);\n        }\n    }\n\n    return digits;\n}\n\n/**\n * Returns the verifier digit for a given input.\n *\n * @param      {Array}   digits  The CPF digits.\n * @return     {Number}  The verifier digit.\n */\nfunction checkSum(digits: Array): Number {\n    if (!Array.isArray(digits)) {\n        throw new Error(`CPF.checkSum Error\\nExpected digits to be an array but instead got ${typeof digits}`);\n    }\n\n    const size = digits.length + 1;\n\n    // Do some magic. JK. forEach number, we multiply it by the array size\n    // plus one (10 or 11 if cpf is valid). Than we sum all the indexes\n    const sum = digits\n        .map((number, index) => number * (size - index))\n        .reduce((total, number) => total + number);\n\n    // We then multiply by 10 and get the remainder of dividing by 11.\n    const remainder = (sum * 10) % 11;\n\n    // If the remainder is 10 or 11, return 0, else return the remainder.\n    return remainder > 9 ? 0 : remainder;\n}\n\n/**\n * Validates a given CPF.\n *\n * @param      {string}   raw     The raw cpf string, it can be dirty, like\n *                                'my cpf is 000.000.000-00'.\n * @return     {boolean}  True if valid, False otherwise.\n */\nfunction validate(raw: String): Boolean {\n    if (!isString(raw)) {\n        throw new Error(`CPF.validate Error\\nExpected CPF to be a string, instead got ${typeof raw}`);\n    }\n\n    // Get the Array<Number> for the CPF's digits\n    const digits = transform(strip(parse(raw)));\n\n    // If length is not 11, CPF is not valid!\n    if (digits.length !== 11) {\n        return false;\n    }\n\n    // We extract the verifier digits from the CPF digits\n    const verifiers = digits.slice(9, 11);\n\n    // We compute the correct verifiers based on the 9 first digits\n    const first = checkSum(digits.slice(0, 9));\n    const second = checkSum(digits.slice(0, 9).concat([first]));\n\n    // We check if the provided verifiers match the computed ones\n    if (verifiers[0] === first && verifiers[1] === second) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Generates a given CPF\n *\n * @return     {String}  The generated CPF\n */\nfunction generate(): String {\n    let randomNum = '';\n\n    // We generate the first nine digits randomly\n    for (let i = 0; i < 9; i += 1) {\n        randomNum = randomNum.concat(random(9, 1).toString(10));\n    }\n\n    // We transform the random digits into an Array<Number> of the digits.\n    const digits = transform(randomNum);\n\n    // Generate the verifiers based on the random digits\n    const first = checkSum(digits.slice(0, 9));\n    const second = checkSum(digits.slice(0, 9).concat([first]));\n\n    // Return a formated version\n    return format(`${digits.join('')}${first}${second}`);\n}\n\nconst CPF = validate;\nCPF.parse = parse;\nCPF.strip = strip;\nCPF.format = format;\nCPF.generate = generate;\n\n\n"]}