{"version":3,"sources":["webpack://CPF/webpack/universalModuleDefinition","webpack://CPF/webpack/bootstrap","webpack://CPF/./src/is-false-positive/index.js","webpack://CPF/./src/get-verifier/index.js","webpack://CPF/./src/constants/index.js","webpack://CPF/./src/assert/index.js","webpack://CPF/./src/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","data","every","verifier","length","mappings","unshift","_defined3","index","_defined","Array","_i4","_defined2","accumulator","_acc","_i3","reminder","sum","CPF_REGEX","INVALID_CODE","LENGTH_CODE","VALID_CODE","condition","message","code","error","Error","isCpfCheck","strip","validate","format","generate","_constants","raw","_assert2","default","toString","_typeof","replace","trim","rawString","split","numbers","string","parseInt","Number","isNaN","_isFalsePositive2","userVerifiers","slice","_getVerifier2","valid","formatted","arguments","undefined","_defined4","fill","prefix","_i6","Math","floor","random","firstVerifier","secondVerifier","concat","finalString","join","defineProperties"],"mappings":"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","file":"cpf.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CPF\"] = factory();\n\telse\n\t\troot[\"CPF\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/**\n * Because of how CPF's validity is calculated, number like 11111111111 are valid.\n * To prevent users from abusing this quirk, we check if CPF string follows this\n * pattern and we invalidade if so.\n * @private\n * @param {Array<number>} data Array containing user provided CPF.\n * @returns {boolean} Wether of not the CPF is a false positive.\n */\nexport default function isFalsePositive(data) {\n    return data.every(value => value === data[0]);\n}\n","/**\n * Do some math to check CPF verifier digits.\n * @private\n * @param {Array<number>} data CPF digits, with 9 or 10 numbers.\n * @param {number} verifier Wether to check the first or second verifiers.\n * @returns {number} The verifier digit.\n */\nexport default function getVerifier(data, verifier) {\n    if (data.length < 9 || data.length > 10) {\n        return -1;\n    } else if (data.length === 9 && verifier === 2) {\n        return -1;\n    } else if (data.length === 10 && verifier === 1) {\n        return -1;\n    }\n\n    const mappings = [10, 9, 8, 7, 6, 5, 4, 3, 2];\n\n    if (verifier === 2) {\n        mappings.unshift(11);\n    }\n\n\n    const sum = mappings\n        .map((value, index) => value * data[index])\n        .reduce((accumulator, value) => accumulator + value, 0);\n\n    const reminder = sum % 11;\n\n    if (reminder < 2) {\n        return 0;\n    }\n\n    return 11 - reminder;\n}\n","export const CPF_REGEX = /^(\\d{3})(.|-)?(\\d{3})(.|-)?(\\d{3})(.|-)?(\\d{2})$/;\n\n// Error codes\nexport const INVALID_CODE = 'INVALID';\nexport const LENGTH_CODE = 'LENGTH';\nexport const VALID_CODE = 'VALID';\n","/**\n * Asserts given condition.\n * @private\n * @param {boolean} condition The condition to assert validity of.\n * @param {string|undefined} message The error message to display during development.\n * @param {string} code The error code.\n */\nexport default function assert(condition, message, code) {\n    if (!condition) {\n        const errorMessage = process.env.NODE_ENV === 'production' ?\n            'cpf-check error. Use dev environment for the full error message.' : `cpf-check Error. ${message}`;\n\n        const error = new Error(errorMessage);\n        error.code = code;\n        error.isCpfCheck = true;\n\n        throw error;\n    }\n}\n","import assert from './assert';\nimport { CPF_REGEX, INVALID_CODE, LENGTH_CODE, VALID_CODE } from './constants';\nimport getVerifier from './get-verifier';\nimport isFalsePositive from './is-false-positive';\n\n/**\n * @typedef {Object} ValidationResult\n * @property {boolean} error Wether there were any erros during validation.\n * @property {boolean} valid Wether the provided CPF is valid.\n * @property {string} code Error or success code.\n */\n\n\n/**\n * Strip '-', '.', and anything that is not a digit from the provided input.\n * @public\n * @param      {string}  raw The text input.\n * @return     {string}  Striped down input.\n */\nexport function strip(raw) {\n    assert(\n        Object.prototype.toString.call(raw) === '[object String]',\n        `Expected String but instead got ${typeof raw}`,\n        INVALID_CODE,\n    );\n\n    return raw.replace(/[^\\d]/g, '').trim();\n}\n\n/**\n * Validates CPF's\n * @public\n * @param {any} rawString Value to validate.\n * @returns {ValidationResult} The result of a given validation.\n */\nexport function validate(rawString) {\n    assert(\n        Object.prototype.toString.call(rawString) === '[object String]',\n        `Expected CPF to be a string insead got ${typeof rawString}`,\n    );\n\n\n    try {\n        assert(\n            rawString.length === 11,\n            `Expected CPF to have length of 11 instead got ${rawString.length}`,\n            LENGTH_CODE,\n        );\n\n        const numbers = rawString\n            .replace(CPF_REGEX, '$1$3$5$7')\n            .split('')\n            .map(string => parseInt(string, 10));\n\n        numbers.forEach((value) => {\n            assert(\n                !Number.isNaN(value),\n                `Expected CPF to have only digits but instead got ${value}`,\n                INVALID_CODE,\n            );\n        });\n\n        assert(\n            !isFalsePositive(numbers),\n            'Provided CPF is a false positive.',\n            INVALID_CODE,\n        );\n\n        const userVerifiers = numbers.slice(9);\n\n        assert(\n            userVerifiers[0] === getVerifier(numbers.slice(0, 9), 1),\n            'Provided CPF is invalid.',\n            INVALID_CODE,\n        );\n\n        assert(\n            userVerifiers[1] === getVerifier(numbers.slice(0, 10), 2),\n            'Provided CPF is invalid.',\n            INVALID_CODE,\n        );\n\n        return {\n            error: false,\n            valid: true,\n            code: VALID_CODE,\n        };\n    } catch (error) {\n        if (error.isCpfCheck) {\n            return {\n                error: true,\n                valid: false,\n                code: error.code,\n            };\n        }\n\n        throw error;\n    }\n}\n\n/**\n * Format a given cpf. For example '00000000000' will result in\n * '000.000.000-00'.\n * @public\n * @param      {string}  raw The unformated CPF.\n * @return     {string}  The formated CPF.\n */\nexport function format(raw) {\n    const { valid } = validate(raw);\n\n    assert(\n        valid,\n        'Cannot format invalid CPF strings.',\n        INVALID_CODE,\n    );\n\n    return strip(raw).replace(CPF_REGEX, '$1.$3.$5-$7');\n}\n\n/**\n * Generate new random valid CPF.\n * @public\n * @param {?boolean} formatted Wether or not to format the output;\n * @returns {string} A random valid CPF string.\n */\nexport function generate(formatted = true) {\n    assert(\n        Object.prototype.toString.call(formatted) === '[object Boolean]',\n        `Expected generate argument to be boolean instead got ${typeof formatted}.`,\n        INVALID_CODE,\n    );\n\n    const prefix = Array(9).fill(0)\n        .map(() => Math.floor(Math.random() * (9 - (1 + 1))) + 1);\n\n    const firstVerifier = getVerifier(prefix, 1);\n    const secondVerifier = getVerifier(prefix.concat(firstVerifier), 2);\n\n    const finalString = `${prefix.join('')}${firstVerifier}${secondVerifier}`;\n\n    return formatted ? format(finalString) : finalString;\n}\n\nexport default Object.defineProperties(validate, {\n    strip: { value: strip },\n    format: { value: format },\n    validate: { value: validate },\n    generate: { value: generate },\n});\n"],"sourceRoot":""}