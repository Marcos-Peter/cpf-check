{"version":3,"sources":["index.js"],"names":["isString","stg","constructor","toString","indexOf","random","max","min","rMin","Math","ceil","rMax","floor","parse","raw","matches","match","strip","replace","trim","format","regex","transform","digits","split","map","digit","parseInt","i","length","Number","isNaN","checkSum","size","remainder","number","index","reduce","total","validate","Error","_typeof","verifiers","slice","first","second","concat","CPF","generate","randomNum","join","define","amd","exports","module","global"],"mappings":"oOAEA,WAOI,SAASA,EAASC,GAEd,OAAyD,IAAlDA,EAAIC,YAAYC,WAAWC,QAAQ,UAU9C,SAASC,EAAOC,EAAaC,GAEzB,IAAMC,EAAOC,KAAKC,KAAKH,GACjBI,EAAOF,KAAKG,MAAMN,GAGxB,OAAOG,KAAKG,MAAMH,KAAKJ,UAAYM,GAAQH,EAAO,KAAOA,EAU7D,SAASK,EAAMC,GAEX,IAAMC,EAAUD,EAAIE,MAAM,0CAG1B,OAAgB,OAAZD,EACO,GAIJA,EAAQ,GASnB,SAASE,EAAMH,GACX,OAAOA,EAAII,QAAQ,SAAU,IAAIC,OAUrC,SAASC,EAAON,GACZ,IAAMO,EAAQ,iCACd,OAAOJ,EAAMJ,EAAMC,IAAMI,QAAQG,EAAO,eAS5C,SAASC,EAAUR,GAMf,IAAK,IAJCS,EAAST,EAAIU,MAAM,IAAIC,IAAI,SAAAC,GAAA,OAASC,SAASD,EAAO,MAIjDE,EAAIL,EAAOM,OAAS,EAAGD,GAAK,EAAGA,GAAK,EACzC,GAAIE,OAAOC,MAAMR,EAAOK,IACpB,SAIR,OAAOL,EASX,SAASS,EAAST,GACd,IAAMU,EAAOV,EAAOM,OAAS,EASvBK,EAAmB,GALbX,EACPE,IAAI,SAACU,EAAQC,GAAT,OAAmBD,GAAUF,EAAOG,KACxCC,OAAO,SAACC,EAAOH,GAAR,OAAmBG,EAAQH,IAGR,GAG/B,OAAOD,EAAY,EAAI,EAAIA,EAU/B,SAASK,EAASzB,GACd,IAAKd,EAASc,GACV,MAAM,IAAI0B,MAAJ,kDAAA,IAA6D1B,EAA7D,YAAA2B,QAA6D3B,KAIvE,IAAMS,EAASD,EAAUL,EAAMJ,EAAMC,KAGrC,GAAsB,KAAlBS,EAAOM,OACP,OAAO,EAIX,IAAMa,EAAYnB,EAAOoB,MAAM,EAAG,IAG5BC,EAAQZ,EAAST,EAAOoB,MAAM,EAAG,IACjCE,EAASb,EAAST,EAAOoB,MAAM,EAAG,GAAGG,QAAQF,KAGnD,OAAIF,EAAU,KAAOE,GAASF,EAAU,KAAOG,EA+BnD,IAAME,EAAMR,EAGZQ,EAAIlC,MAAQA,EACZkC,EAAI9B,MAAQA,EACZ8B,EAAI3B,OAASA,EACb2B,EAAIf,SAAWA,EACfe,EAAIzB,UAAYA,EAChByB,EAAIR,SAAWA,EACfQ,EAAIC,SA5BJ,WAII,IAAK,IAHDC,EAAY,GAGPrB,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACxBqB,EAAYA,EAAUH,OAAOzC,EAAO,EAAG,GAAGF,SAAS,KAIvD,IAAMoB,EAASD,EAAU2B,GAGnBL,EAAQZ,EAAST,EAAOoB,MAAM,EAAG,IACjCE,EAASb,EAAST,EAAOoB,MAAM,EAAG,GAAGG,QAAQF,KAGnD,OAAOxB,EAAAA,GAAUG,EAAO2B,KAAK,IAAMN,EAAQC,IAezB,mBAAXM,QAAyBA,OAAOC,IACvCD,OAAO,WAAA,OAAMJ,IACa,oBAAZM,SAEQ,oBAAXC,QAA0BA,OAAOD,UACxCA,QAAUN,EACVO,OAAOD,QAAUN,GAGrBM,QAAQN,IAAMA,GACW,oBAAXQ,SAEdA,OAAOR,IAAMA,GApMrB","file":"cpf.fa5b047e.19b500f4.min.js","sourcesContent":["// @flow\n\n(() => {\n    /**\n     * Determines if given input is a string.\n     *\n     * @param      {Any}   stg     The input.\n     * @return     {boolean}  True if string, False otherwise.\n     */\n    function isString(stg: any): Boolean {\n        // failproffish check\n        return stg.constructor.toString().indexOf('String') !== -1;\n    }\n\n    /**\n     * Returns a random number inside the min-max window.\n     *\n     * @param      {number}  max     The maximum number.\n     * @param      {number}  min     The minimum number.\n     * @return     {number}  the random number.\n     */\n    function random(max: Number, min: Number): Number {\n        // Round given range numbers\n        const rMin = Math.ceil(min);\n        const rMax = Math.floor(max);\n\n        // Generates a pseudo-random number with the given range\n        return Math.floor(Math.random() * (rMax - (rMin + 1))) + rMin;\n    }\n\n    /**\n     * Parse a CPF from any text. For example 'this is my cpf 000.000.000-00'\n     * will return '000.000.000-00'.\n     *\n     * @param      {string}  raw     The raw text string.\n     * @return     {string}  the found CPF or an empty string.\n     */\n    function parse(raw: String): String {\n        // Extracts all cpf matches from an text string\n        const matches = raw.match(/\\d{3}(.|-)?\\d{3}(.|-)?\\d{3}(.|-)?\\d{2}/);\n\n        // If no matches\n        if (matches === null) {\n            return '';\n        }\n\n        // Return the first match\n        return matches[0];\n    }\n\n    /**\n     * Strip '-', '.', and anything that is not a digit from the provided input.\n     *\n     * @param      {string}  raw     The text input.\n     * @return     {string}  Striped down input.\n     */\n    function strip(raw: String): String {\n        return raw.replace(/[^\\d]/g, '').trim();\n    }\n\n    /**\n     * Format a given cpf. For example '00000000000' will result in\n     * '000.000.000-00'.\n     *\n     * @param      {string}  raw     The unformated CPF.\n     * @return     {string}  The formated CPF.\n     */\n    function format(raw: String): String {\n        const regex = /^(\\d{3})(\\d{3})(\\d{3})(\\d{2})$/;\n        return strip(parse(raw)).replace(regex, '$1.$2.$3-$4');\n    }\n\n    /**\n     * Transforms a given CPF string into an Array of the cpfs numbers.\n     *\n     * @param      {string}  raw     The raw cpf string.\n     * @return     {Array}   CPF parsed numbers in an array.\n     */\n    function transform(raw: String): Array {\n        // Transform input into array and parse the numbers\n        const digits = raw.split('').map(digit => parseInt(digit, 10));\n\n        // if the input did't contain a CPF, parseInt will return NaN, so\n        // we check for this.\n        for (let i = digits.length - 1; i >= 0; i -= 1) {\n            if (Number.isNaN(digits[i])) {\n                return [];\n            }\n        }\n\n        return digits;\n    }\n\n    /**\n     * Returns the verifier digit for a given input.\n     *\n     * @param      {Array}   digits  The CPF digits.\n     * @return     {Number}  The verifier digit.\n     */\n    function checkSum(digits: Array): Array {\n        const size = digits.length + 1;\n\n        // Do some magic. JK. forEach number, we multiply it by the array size\n        // plus one (10 or 11 if cpf is valid). Than we sum all the indexes\n        const sum = digits\n            .map((number, index) => number * (size - index))\n            .reduce((total, number) => total + number);\n\n        // We then multiply by 10 and get the remainder of dividing by 11.\n        const remainder = (sum * 10) % 11;\n\n        // If the remainder is 10 or 11, return 0, else return the remainder.\n        return remainder > 9 ? 0 : remainder;\n    }\n\n    /**\n     * Validates a given CPF.\n     *\n     * @param      {string}   raw     The raw cpf string, it can be dirty, like\n     *                                'my cpf is 000.000.000-00'.\n     * @return     {boolean}  True if valid, False otherwise.\n     */\n    function validate(raw: String): Boolean {\n        if (!isString(raw)) {\n            throw new Error(`Expected CPF to be a string, instead got ${typeof raw}`);\n        }\n\n        // Get the Array<Number> for the CPF's digits\n        const digits = transform(strip(parse(raw)));\n\n        // If length is not 11, CPF is not valid!\n        if (digits.length !== 11) {\n            return false;\n        }\n\n        // We extract the verifier digits from the CPF digits\n        const verifiers = digits.slice(9, 11);\n\n        // We compute the correct verifiers based on the 9 first digits\n        const first = checkSum(digits.slice(0, 9));\n        const second = checkSum(digits.slice(0, 9).concat([first]));\n\n        // We check if the provided verifiers match the computed ones\n        if (verifiers[0] === first && verifiers[1] === second) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates a given CPF\n     *\n     * @return     {String}  The generated CPF\n     */\n    function generate(): String {\n        let randomNum = '';\n\n        // We generate the first nine digits randomly\n        for (let i = 0; i < 9; i += 1) {\n            randomNum = randomNum.concat(random(9, 1).toString(10));\n        }\n\n        // We transform the random digits into an Array<Number> of the digits.\n        const digits = transform(randomNum);\n\n        // Generate the verifiers based on the random digits\n        const first = checkSum(digits.slice(0, 9));\n        const second = checkSum(digits.slice(0, 9).concat([first]));\n\n        // Return a formated version\n        return format(`${digits.join('')}${first}${second}`);\n    }\n\n    const CPF = validate;\n\n    // Export the API\n    CPF.parse = parse;\n    CPF.strip = strip;\n    CPF.format = format;\n    CPF.checkSum = checkSum;\n    CPF.transform = transform;\n    CPF.validate = validate;\n    CPF.generate = generate;\n\n    // This supports AMD modules\n    if (typeof define === 'function' && define.amd) {\n        define(() => CPF);\n    } else if (typeof exports !== 'undefined') {\n        // This supports CommonJs and Note modules\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = CPF;\n            module.exports = CPF;\n        }\n        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)\n        exports.CPF = CPF;\n    } else if (typeof global !== 'undefined') {\n        // eslint-disable-next-line no-param-reassign\n        global.CPF = CPF;\n    }\n})();\n"]}